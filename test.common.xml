<project name="common">
	<taskdef resource="net/sf/antcontrib/antcontrib.properties"/>
	<taskdef resource="net/sf/antcontrib/antlib.xml"/>

	<condition property="Product.TIC" else="false">
		<or>
			<contains string="${ProductName}" substring="TIC"/>
			<contains string="${ProductName}" substring="BISuite"/>
		</or>
	</condition>

	<condition property="Product.TDECP" else="false">
		<or>
			<contains string="${ProductName}" substring="TDECP"/>
			<contains string="${ProductName}" substring="TDPV"/>
		</or>
	</condition>
	
	<condition property="Product.DataPoint" else="false">
		<contains string="${ProductName}" substring="DataPoint"/>
	</condition>

	<if>
		<equals arg1="${Product.TIC}" arg2="true"/>
		<then>
			<property name="ProductFamily" value="TIC"/>
		</then>
		<elseif>
			<equals arg1="${Product.DataPoint}" arg2="true"/>
			<then>
				<property name="ProductFamily" value="DataPoint"/>
			</then>
		</elseif>
		<elseif>
			<equals arg1="${Product.TDECP}" arg2="true"/>
			<then>
				<property name="ProductFamily" value="TDECP"/>
			</then>
		</elseif>
	</if>

	<property environment="JenkinsEnv"/>
	<property name="Automation.TestExecutable" value="TestExecute"/>

	<!-- Check whether AutomationVM property exists-->
	<if>
		<isset property="AutomationVM"/>
		<then>
			<!-- Get First and Second VM when started two VMs-->
			<script language="javascript"> <![CDATA[			  
			var AutomationVMTmp = project.getProperty("AutomationVM");				
			var VMs = AutomationVMTmp.split("&");	
			if(VMs.length>1){			 
				project.setProperty("FirstVM",VMs[0]);				
				project.setProperty("SecondVM",VMs[1]);	
			}else if(VMs.length==1){
				project.setProperty("FirstVM",VMs[0]);
			}
			]]> </script>
		</then>
		<!-- We should not fail job if AutomationVM is not set, 
			this is because for multi-configuration jobs, the user-defined axis AutomationVM only works for its sub jobs, but not for itself.
			If we fail job here, then we might see a multi-configuration job fails as 'AutomationVM not set', but with its sub jobs all passed.-->
		<else>
			<if>
				<not>
					<equals arg1="${JenkinsEnv.NODE_NAME}" arg2="master" />
				</not>
				<then>
					<property name="FirstVM" value="${JenkinsEnv.COMPUTERNAME}" />
				</then>
			</if>
		</else>
	</if>
	
	<!--SiteCode is passed in Jenkins job's ant properties, in skytap, we don't need ESX actions anymore-->
	<condition property="domain.prod">
		<not>
			<equals arg1="${SiteCode}" arg2="skytap"/>
		</not>
	</condition>
	
	<!-- .Properties file need to use above JenkinsEnv property-->
	<property file="./${SiteCode}/Build_${ProductFamily}.Properties"/>
	
	<target name="EchoAntProperty">
		<echo message="OSName: ${JenkinsEnv.COMPUTERNAME}"/>
		<echo message="Job WorkSpace: ${JobWorkSpace.dir}"/>
		<echo message="TestBranch=${TEST_BRANCH}"/>
		<echo message="InstallerName=${INSTALLER_NAME}"/>
		<echo message="AutomationVM=${AutomationVM}"/>
		<echo message="TestTool=${Automation.TestExecutable}"/>
		<echo message="Automation.AntUtilities.Dir=${Automation.AntUtilities.dir}"/>
		<echo message="Automation.AntScripts.dir=${Automation.AntScripts.dir}"/>
		<echo message="Automation.TCScripts.dir=${Automation.TCScripts.dir}"/>
		<echo message="Automation.Work.Dir=${Automation.Work.dir}"/>
		<echo message="AutomationProjectDir=${Automation.Project.dir}"/>
		<echo message="domain.prod=${domain.prod}" />
		<echo message="ProductFamily=${ProductFamily}"/>
		<echo message="SiteCode=${SiteCode}"/>
	</target>
	
	<target name="InitJenkinsServerJobWorkSpace">
		<trycatch property="Msg.DeleteTestResult">
			<try>
				<echo message="Clean up previous test results in: ${Automation.TestResults.dir}"/>
				<delete includeemptydirs="true">
					<fileset dir="${Automation.TestResults.dir}" includes="**/*"/>
				</delete>
			</try>
			<catch>
				<echo message="${Msg.DeleteTestResult}" />
			</catch>
		</trycatch>
	</target>

	<target name="GetLatestBuild">
		<java jar="${Automation.AntUtilities.dir}/JenkinsFileUtils.jar" fork="true" failonerror="false" maxmemory="128m" outputproperty="JenkinsServerLatestBuild">
			<arg value="-jar"/>
			<arg value="GetLatestBuild"/> 
			<arg value="installerDir=${FileServer.ProductInstaller.dir}"/>
			<arg value="productName=${ProductName}"/>
			<arg value="devBranch=${INSTALLER_BRANCH}"/>
			<classpath>
				<pathelement location="${Automation.AntUtilities.dir}/JenkinsFileUtils.jar"/>
				<pathelement path="${java.class.path}"/>
			</classpath>
		</java>
		<property name ="LatestBuildWithVersion" value="${JenkinsServerLatestBuild}"/>
		<echo message="Latest Build Version is : ${LatestBuildWithVersion}"/>
		
		<if>
			<equals arg1="${LatestBuildWithVersion}" arg2="Non Exist"/>
			<then>
				<fail message="Failed to get latest build for ${ProductName} from ${FileServer.ProductInstaller.dir}!"/>
			</then>
		</if> 
	</target>

	<target name="GetInstallerFileName">
		<if>
			<not>
				<isset property="InstallerFileName"/>
			</not>
			<then>
				<condition property="INSTALLER_NAME.Empty" else="false">
					<or>
						<not>
							<isset property="INSTALLER_NAME"/>
						</not>	
						<equals arg1="${INSTALLER_NAME}" arg2=""/>
					</or>
				</condition>
				<if>
					<equals arg1="${INSTALLER_NAME.Empty}" arg2="true"/>
					<then>
						<echo message="Call GetLatestBuild targert to get Installler file name"/>
						<antcallback target="GetLatestBuild" return="LatestBuildWithVersion"/>
						<property name="InstallerFileName" value="${LatestBuildWithVersion}"/>
					</then>
					<else>
						<property name="InstallerFileName" value="${INSTALLER_NAME}"/>
					</else>
				</if>
			</then>
		</if>
		<echo message="The Installer file name is : ${InstallerFileName}"/>
	</target>

	<target name="SetBuildDisplayName">
		<!-- Call target GetInstallerFileName to get Installer file name, only the parent job of Matrix job do this -->
	 <if>
		<equals arg1="${SiteCode}" arg2="skytap"/>
		<then>
		    <if>
		        <not>
		          <equals arg1="${Test.Type}" arg2="E2E1"/>
		        </not>
	            <then>
				  <echo message="The build display name is already set"/>
		        </then>
		    </if>
		</then>
		<else>
			<if>
				<or>
					<equals arg1="${InstallerFileName}" arg2="$${InstallerFileName}"/>
					<equals arg1="InstallerFileName" arg2=""/>
				</or>
				<then>
					<echo message="Call target GetInstallerFileName to get Installer name"/>
					<antcallback target="GetInstallerFileName" return="InstallerFileName" />
				</then>
			</if>
		
			<!-- Replace product full name with product prefix and remove suffix if the InstallerFileName is installer full name -->
			<var name="BuildDisplayName" value="${InstallerFileName}"/>
			<propertyregex property="InstallerFileNameWithSuffix" input="${BuildDisplayName}" regexp="ToadBISuiteInstaller" replace="BISuite" global="true" defaultvalue="${BuildDisplayName}"/>
			<!-- Since a property value cannot be set value twice, so we have to save its value and unset it-->
			<var name="BuildDisplayName" value="${InstallerFileNameWithSuffix}"/>
			<var name="InstallerFileNameWithSuffix" unset="true"/>
		
			<propertyregex property="InstallerFileNameWithSuffix" input="${BuildDisplayName}" regexp="ToadIntelligenceCentralServerInstaller" replace="TICBundle" global="true" defaultvalue="${BuildDisplayName}"/>
			<!-- Since a property value cannot be set value twice, so we have to save its value and unset it-->
			<var name="BuildDisplayName" value="${InstallerFileNameWithSuffix}"/>
			<var name="InstallerFileNameWithSuffix" unset="true"/>

			<propertyregex property="InstallerFileNameWithSuffix" input="${BuildDisplayName}" regexp="ToadDecisionPointPro" replace="TDECP" global="true" defaultvalue="${BuildDisplayName}"/>
			<var name="BuildDisplayName" value="${InstallerFileNameWithSuffix}"/>
			<var name="InstallerFileNameWithSuffix" unset="true"/>

			<propertyregex property="InstallerFileNameWithSuffix" input="${BuildDisplayName}" regexp="ToadDataPointViewer" replace="TDPV" global="true" defaultvalue="${BuildDisplayName}"/>
			<var name="BuildDisplayName" value="${InstallerFileNameWithSuffix}"/>
			<var name="InstallerFileNameWithSuffix" unset="true"/>
		
			<!-- ToadIntelligenceCentralAdminConsole contains sub string ToadIntelligenceCentral, so we replace ToadIntelligenceAdminConsole at first -->
			<propertyregex property="InstallerFileNameWithSuffix" input="${BuildDisplayName}" regexp="ToadIntelligenceCentralAdminConsole" replace="TICAC" global="true" defaultvalue="${BuildDisplayName}"/>
			<var name="BuildDisplayName" value="${InstallerFileNameWithSuffix}"/>
			<var name="InstallerFileNameWithSuffix" unset="true"/>

			<propertyregex property="InstallerFileNameWithSuffix" input="${BuildDisplayName}" regexp="ToadIntelligenceCentral" replace="TIC" global="true" defaultvalue="${BuildDisplayName}"/>
			<var name="BuildDisplayName" value="${InstallerFileNameWithSuffix}"/>
			<var name="InstallerFileNameWithSuffix" unset="true"/>

			<propertyregex property="DisplayInstallerFileName" input="${BuildDisplayName}" regexp=".exe" replace="" global="true" defaultvalue="${BuildDisplayName}"/>
			<var name="BuildDisplayName" value="${DisplayInstallerFileName}"/>
			<var name="DisplayInstallerFileName" unset="true"/>

			<propertyregex property="DisplayInstallerFileName" input="${BuildDisplayName}" regexp=".msi" replace="" global="true" defaultvalue="${BuildDisplayName}"/>

			<echo message="Display Build version : ${DisplayInstallerFileName}"/>
			<echo message="Jenkins Job Url: ${JenkinsEnv.JENKINS_URL}"/>
			<echo message="Jenkins Job Name: ${JenkinsEnv.JOB_NAME}"/>

			<if>
				<equals arg1="${SiteCode}" arg2="skytap"/>
					<then>
						<java jar="${Automation.AntUtilities.dir}/jenkins-cli.jar" fork="true" failonerror="true" maxmemory="128m">
							<arg value="-s"/> 
							<arg line="${JenkinsEnv.JENKINS_URL}"/>
							<arg value="set-build-display-name"/>
							<arg value="${JenkinsEnv.JOB_NAME}"/>
							<arg value="${JenkinsEnv.BUILD_NUMBER}"/>
							<arg value="#${JenkinsEnv.BUILD_NUMBER} ${DisplayInstallerFileName}"/>
							<arg line="--username"/>
							<arg line="${JenkinsServer.Username}"/>
							<arg line="--password"/>
							<arg line="${JenkinsServer.Password}"/>
							<classpath>
								<pathelement location="${Automation.AntUtilities.dir}/jenkins-cli.jar"/>
								<pathelement path="${java.class.path}"/>
							</classpath>
						</java>
					</then>
				<else>
						<java jar="${Automation.AntUtilities.dir}/jenkins-cli.jar" fork="true" failonerror="true" maxmemory="128m">
							<arg value="-s"/> 
							<arg line="${JenkinsEnv.JENKINS_URL}"/>
							<arg value="set-build-display-name"/>
							<arg value="${JenkinsEnv.JOB_NAME}"/>
							<arg value="${JenkinsEnv.BUILD_NUMBER}"/>
							<arg value="#${JenkinsEnv.BUILD_NUMBER} ${DisplayInstallerFileName}"/>
							<classpath>
								<pathelement location="${Automation.AntUtilities.dir}/jenkins-cli.jar"/>
								<pathelement path="${java.class.path}"/>
							</classpath>
						</java>
				</else>
			</if>
			<echo message="Set build display name : ${DisplayInstallerFileName}"/>
		</else>
	</if>
	</target>

	<!--This target for automation which is running in ESX VM, and not for smoke test which is running on slave-->
	<target name="StartVMToPrebuild" if="domain.prod">
		<if>
			<!--For smoke test running on slave VM. The VM keeps on-line all the time, no need to start, just delete snapshot for it.-->
			<equals arg1="${Test.Type}" arg2="smoke"/>
			<then>
				<antcall target="DeleteFailedSnapshots"/>
			</then>
			<else>
				<if>
					<!--Don't start VM to prebuild if job says NO-->
					<not>
						<equals arg1="${StartVMToPrebuild}" arg2="false"/>
					</not>
					<then>
						<echo message="Calling ExecuteEsxCommand to start VM on ESX using powershell scripts ."/>
						<!-- check whether need start second VM for upgrade remote test -->
						<if>
							<isset property="SecondVM"/>
							<then>
								<echo message="Start Second VM for upgrade remote tests."/>
								<antcallback target="ExecuteEsxCommand" return="EsxCommandReturnCode">
									<param name="argCommand" value="start"/>
									<param name="AutomationExecuteVM" value="${SecondVM}"/>
								</antcallback>
								<if>
									<not>
										<equals arg1="${EsxCommandReturnCode}" arg2="0"/>
									</not>
									<then>
										<fail message="Jenkins job failed to start automation VM ${SecondVM}."/>
									</then>
								</if>
							</then>
						</if>
						<!--Inside this VM start task, it contains 'DeleteFailedSnapshots' / 'RevertSnapshot' / 'StartVM' three steps.-->
						<echo message="Start Automation VM."/>
						<antcallback target="ExecuteEsxCommand" return="EsxCommandReturnCode">
							<param name="argCommand" value="start"/>
							<param name="AutomationExecuteVM" value="${FirstVM}"/>
						</antcallback>

						<if>
							<not>
								<equals arg1="${EsxCommandReturnCode}" arg2="0"/>
							</not>
							<then>
								<fail message="Jenkins job failed to start automation VM ${FirstVM}"/>
							</then>
						</if>
						<!--Why need this ipconfig & flushdns?-->
						<echo message="execute ipconfig /flushdns on jenkins server."/>
						<exec executable="cmd">
							<arg value="/c" />
							<arg value="ipconfig" />
							<arg value="/flushdns" />
						</exec>
					</then>
				</if>
			</else>
		</if>
	</target>

	<target name="DeleteFailedSnapshots" if="domain.prod">
		<echo message="Calling ExecuteEsxCommand to start VM on ESX using powershell scripts ."/>
		<!-- check whether need start second VM for upgrade remote test -->
		<if>
			<isset property="SecondVM"/>
			<then>
				<echo message="Start Second VM for upgrade remote tests."/>
				<antcallback target="ExecuteEsxCommand" return="EsxCommandReturnCode">
					<param name="argCommand" value="deletefailedsnapshots"/>
					<param name="AutomationExecuteVM" value="${SecondVM}"/>
				</antcallback>
				<if>
					<not>
						<equals arg1="${EsxCommandReturnCode}" arg2="0"/>
					</not>
					<then>
						<fail message="Failed to remove snapshot from test VM ${SecondVM}"/>
					</then>
				</if>
			</then>
		</if>

		<echo message="Delete Failed Snapshots."/>
		<antcallback target="ExecuteEsxCommand" return="EsxCommandReturnCode">
			<param name="argCommand" value="deletefailedsnapshots"/>
			<param name="AutomationExecuteVM" value="${FirstVM}"/>
		</antcallback>

		<if>
			<not>
				<equals arg1="${EsxCommandReturnCode}" arg2="0"/>
			</not>
			<then>
				<fail message="Failed to remove snapshot from test VM ${FirstVM}"/>
			</then>
		</if>
	</target>
	
	<target name="CopyAutomationFilesToVM">
		<java jar="${Automation.AntUtilities.dir}/JenkinsFileUtils.jar" fork="true" failonerror="false" maxmemory="128m" resultproperty="CopyAutomationFilesToVMResult" outputproperty="CopyAutomationFilesToVMOutput">
			<arg value="-jar"/>
			<arg value="CopyAutomationFilesToVM"/> 
			<arg value="testScriptDir=${Automation.TCScripts.dir}"/>
			<arg value="installerDir=${FileServer.ProductInstaller.dir}"/>
			<arg value="automationDir=${Automation.Work.dir}"/>
			<arg value="installerName=${InstallerFileName}"/>
			<arg value="testBranch=${TEST_BRANCH}"/>
			<arg value="siteCode=${SiteCode}"/>
			<classpath>
				<pathelement location="${Automation.AntUtilities.dir}/JenkinsFileUtils.jar"/>
				<pathelement path="${java.class.path}"/>
			</classpath>
		</java>

		<echo message="CopyAutomationFilesToVMResult: ${CopyAutomationFilesToVMResult}"/>
		<echo message="CopyAutomationFilesToVMOutput: ${CopyAutomationFilesToVMOutput}"/>
		<if>
			<not>
				<equals arg1="${CopyAutomationFilesToVMResult}" arg2="0"/>
			</not>
			<then>
				<antcall target= "TakeFailedSnapshotOnVM"/>
				<antcall target="PowerOffVM"/>
				<fail message="Cannot copy latest build version from ${FileServer.ProductInstaller.dir} to ${Automation.Work.dir}. Jenkins job will stop!"/>
			</then>
		</if> 
	</target>

	<target name="RunTestCasesOnVM">
		<echo message="-----------------Error code information--------------------------"/>
		<echo message="if wscript returns 0,it means testcase run successful!"/>
		<echo message="if wscript returns 1,it means testcase has a warning!"/>
		<echo message="if wscript returns 2,it means testcase run failed!"/>
		<echo message="if wscript returns 1000,it means Testcomplete was already running and testcomplete can not open the project."/>
		<echo message="-----------------------------------------------------------------"/>
		<!-- check whether need start second VM for upgrade remote test -->
		<if>
			<isset property="SecondVM"/>
			<then>
				<property name="TestParameterSet" value="&quot;${TestParameters},SecondVM=${SecondVM},SITE_CODE=${SiteCode}&quot;"/>
			</then>
			<else>
				<property name="TestParameterSet" value="&quot;${TestParameters},SITE_CODE=${SiteCode}&quot;"/>
			</else>
		</if>
		<echo message="-----------------Basic information------------------------------"/>
		<echo>AutomationVM:                           ${FirstVM}</echo>
		<echo>Automation.Local.dir :                  ${Automation.Local.dir}</echo>
		<echo>Automation TestUser:                    ${Automation.TestUser}</echo>
		<echo>Automation TestPassword:                ${Automation.TestPassword}</echo>
		<echo>Automation TestExecutable:              ${Automation.TestExecutable}</echo>
		<echo>Automation ProjectSuit:                 ${Automation.pjs}</echo>
		<echo>Automation TestParameters:              ${TestParameterSet}</echo>
		<echo message="------------------------------------------------------------------"/>
		<echo message="${Automation.Local.dir}\RunGroup.vbs ${Automation.TestExecutable} ${Automation.Local.dir}\${Automation.pjs} ${TestCompleteProjectName} ${RunGroupName} ${TestParameterSet}" />
		<echo message="Execute psexec to run automation tests..."/>
		<exec executable="psexec" failonerror="false" timeout="18000000" outputproperty="PsexecOutput" errorproperty="PsexecErrorMsg" resultproperty="PsexecResultCode">
			<arg value="\\${FirstVM}"/>
			<arg value="-n"/>
			<arg value="60"/>
			<arg line="-u ${Automation.TestUser} -p ${Automation.TestPassword}"/> 
			<arg line="-i -h wscript"/>
			<arg line="${Automation.Local.dir}\RunGroup.vbs ${Automation.TestExecutable} ${Automation.Local.dir}\${Automation.pjs} ${TestCompleteProjectName} ${RunGroupName} ${TestParameterSet}"/>
		</exec>
		<echo message="===================PsexecOutput=========================="/>
		<echo message="${PsexecOutput}"/>
		<echo message="${PsexecErrorMsg}"/>
		<echo message="PsexecResultCode: ${PsexecResultCode}"/>
		<echo message="===================PsexecOutput end======================="/>
		<if>
			<not>
				<equals arg1="${PsexecResultCode}" arg2="0"/>
			</not>
			<then>
				<echo message="Calling TakeFailedSnapshotOnVM."/>
				<antcall target= "TakeFailedSnapshotOnVM"/>
			</then>
		</if>
	</target>

	<!--Keep in mind that this ant is being executed on Jenkins server, not in test VM, so we need a network path to copy log files-->
	<target name="ProcessTestCasesResults">
	<if>
		<!--For E2E test running in Skytap.-->
		<contains string="${Test.Type}" substring="E2E"/>
		<then>
			<trycatch property="Msg.ProdessTestResult">
			<try>
				<!-- Copy the raw automation logs to a folder under job workspace. -->
				<echo message="Copy automation raw log from ${Automation.Project.dir} to ${Automation.TestResults.dir}\${Test.Type}"/>
				<copy todir="${Automation.TestResults1.dir}\${Test.Type}" flatten="true" overwrite="true">
					<fileset dir="${Automation.Project.dir}">
						<include name="**/Log/**/{*}"/>
					</fileset>
				</copy>

				<!-- Copy the TestComplete converted log to a folder under job workspace. -->
				<!-- The TestComplte result in html format is used by Jenkins to render the job report web pages. -->
				<echo message="Copy converted html log from ${Automation.ConvertedLog.dir} to ${Automation.TestResults.dir}\${Test.Type}\html"/>
				<copy todir="${Automation.TestResults.dir}\${Test.Type}/html">
					<fileset dir="${Automation.ConvertedLog.dir}"/>
				</copy>

				<!-- Copy support bundle to a folder under job workspace. We can only archive files that are located in job workspace. -->	
				<if>
					<or>
						<equals arg1="${Product.TIC}" arg2="true"/>
						<equals arg1="${Product.TDECP}" arg2="true"/>
					</or>
					<then>
						<echo message="Copying support bundle from ${Automation.Project.dir}\RawResultsInXml\Support to ${Automation.TestResults.dir}\${Test.Type}\Support_Bundle" />
						<copy todir="${Automation.TestResults.dir}\${Test.Type}/Support_Bundle">
							<fileset dir="${Automation.Project.dir}/RawResultsInXml/Support"/>
						</copy>
					</then>
				</if>   
			</try>
			<catch>
				<echo message="${Msg.ProdessTestResult}"/>
			</catch>
			<finally>
				<!-- Use Dephi programe to convert TestComplete Raw Log from Xml into JUnit format. The JUnit format results is used by Jenkins to determine the job status. -->
				<exec executable="${Automation.AntUtilities.dir}/TestCompleteResultsTransform.exe" failonerror="true" timeout="10800000">
					<arg value="${Automation.TestResults.dir}\${Test.Type}"/>
				</exec>
			</finally>
		    </trycatch>
		</then>
	</if> 
		<trycatch property="Msg.ProdessTestResult">
			<try>
				<!-- Copy the raw automation logs to a folder under job workspace. -->
				<echo message="Copy automation raw log from ${Automation.Project.dir} to ${Automation.TestResults.dir}"/>
				<copy todir="${Automation.TestResults1.dir}" flatten="true" overwrite="true">
					<fileset dir="${Automation.Project.dir}">
						<include name="**/Log/**/{*}"/>
					</fileset>
				</copy>

				<!-- Copy the TestComplete converted log to a folder under job workspace. -->
				<!-- The TestComplte result in html format is used by Jenkins to render the job report web pages. -->
				<echo message="Copy converted html log from ${Automation.ConvertedLog.dir} to ${Automation.TestResults.dir}\html"/>
				<copy todir="${Automation.TestResults.dir}/html">
					<fileset dir="${Automation.ConvertedLog.dir}"/>
				</copy>

				<!-- Copy support bundle to a folder under job workspace. We can only archive files that are located in job workspace. -->	
				<if>
					<or>
						<equals arg1="${Product.TIC}" arg2="true"/>
						<equals arg1="${Product.TDECP}" arg2="true"/>
					</or>
					<then>
						<echo message="Copying support bundle from ${Automation.Project.dir}\RawResultsInXml\Support to ${Automation.TestResults.dir}\Support_Bundle" />
						<copy todir="${Automation.TestResults.dir}/Support_Bundle">
							<fileset dir="${Automation.Project.dir}/RawResultsInXml/Support"/>
						</copy>
					</then>
				</if>   
			</try>
			<catch>
				<echo message="${Msg.ProdessTestResult}"/>
			</catch>
			<finally>
				<!-- Use Dephi programe to convert TestComplete Raw Log from Xml into JUnit format. The JUnit format results is used by Jenkins to determine the job status. -->
				<exec executable="${Automation.AntUtilities.dir}/TestCompleteResultsTransform.exe" failonerror="true" timeout="10800000">
					<arg value="${Automation.TestResults.dir}"/>
				</exec>
			</finally>
		</trycatch>
	</target>

	<!--Remove C:\Automation from test VM-->
	<target name="DeleteAutomationFilesOnVM">
		<trycatch property="Msg.DeleteAutomationFiles">
			<try>
				<echo message="Delete automation files ${Automation.Work.dir} on VM"/>
				<delete includeEmptyDirs="true">
					<fileset dir="${Automation.Work.dir}" excludes="NightlyBuild/"/>
				</delete>
			</try>
			<catch>
				<echo message="${Msg.DeleteAutomationFiles}"/>
			</catch>
		</trycatch>
	</target>

	<target name="PowerOffVM" if="domain.prod">
		<if>
			<!--Not for smoke test which is running on slave VM-->
			<not>
				<equals arg1="${Test.Type}" arg2="smoke"/>
			</not>
			<then>
				<if>
					<!--Usually will power off VM by default unless job says NO-->
					<not>
						<equals arg1="${PowerOffVM}" arg2="false"/>
					</not>
					<then>
						<!-- check whether need shut down second VM for upgrade remote test -->
						<if>
							<isset property="SecondVM"/>
							<then>
								<echo message="Shut down Second VM:${SecondVM}"/>
								<antcall target="PowerOffAllAutomationVMOnEsx">
									<param name="FirstVM" value="${SecondVM}"/>
								</antcall>
							</then>
						</if>
						<echo message="Shut down the Automation VM:${FirstVM}"/>

						<antcall target="PowerOffAllAutomationVMOnEsx"/>
					</then>
					<!--If not power off VM, then need to clean up automation work directory for next job-->
					<else>
						<antcall target="DeleteAutomationFilesOnVM"/>
					</else>
				</if>
			</then>
		</if>
	</target>

	<target name="TakeFailedSnapshotOnVM" if="domain.prod">
		<echo message="Calling ExecuteEsxCommand."/>
		<antcall target="ExecuteEsxCommand">
			<param name="argCommand" value="snapshotfailure"/>
			<param name="AutomationExecuteVM" value="${FirstVM}"/>
		</antcall>
	</target>

	<target name="ExecuteEsxCommand" if="domain.prod">
		<echo message="================================================"/>
		<echo message="argCommand    ${argCommand}" />
		<echo message="AutomationVM  ${AutomationExecuteVM}"/>
		<echo message="ESX_NAME      ${ESX_NAME}"/>
		<echo message="ESX_USERNAME  ${ESX_USERNAME}"/>
		<echo message="ESX_PASSWORD  ${ESX_PASSWORD}"/>	
		<echo message="================================================"/>
		<exec dir="${Automation.AntScripts.dir}" executable="powershell" failonerror="false" errorproperty="ErrorMessage" resultproperty="PowerShellErrorCode">
			<arg value="-File"/>
			<arg value="ESXUtilities.ps1"/>
			<arg value="${argCommand}"/>
			<arg value="${AutomationExecuteVM}"/>
			<arg value="${ESX_NAME}"/>
			<arg value="${ESX_USERNAME}"/>
			<arg value="${ESX_PASSWORD}"/>   
		</exec>

		<echo message="${ErrorMessage}"/>
		<property name="EsxCommandReturnCode" value="${PowerShellErrorCode}"/>
	</target>

	<target name="PowerOffAllAutomationVMOnEsx" if="domain.prod">
		<antcallback target="ExecuteEsxCommand" return="EsxCommandReturnCode">
			<param name="argCommand" value="shutdown"/>
			<param name="AutomationExecuteVM" value="${FirstVM}"/>
		</antcallback>

		<if>
			<not>
				<equals arg1="${EsxCommandReturnCode}" arg2="0"/>
			</not>
			<then>
				<fail message="Failed to power off ${FirstVM}"/>
			</then>
		</if>
	</target>

	<target name="DeletePrebuild" if="domain.prod">
		<antcallback target="ExecuteEsxCommand" return="EsxCommandReturnCode">
			<param name="argCommand" value="deleteprebuild"/>
			<param name="AutomationExecuteVM" value="${FirstVM}"/>
		</antcallback>
	</target>

	<target name="CreatePrebuild" if="domain.prod">
		<antcallback target="ExecuteEsxCommand" return="EsxCommandReturnCode">
			<param name="argCommand" value="createprebuild"/>
			<param name="AutomationExecuteVM" value="${FirstVM}"/>
		</antcallback>
	</target>
</project>